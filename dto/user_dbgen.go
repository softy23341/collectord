// !! Autogenerated file, do not edit!
package dto

import (
	"bytes"
	"errors"
	"fmt"

	"github.com/jackc/pgx"
	"github.com/jackc/pgx/pgtype"
)

// UserField TBD
type UserField int

const (
	// UserFieldID TBD
	UserFieldID UserField = iota

	// UserFieldFirstName TBD
	UserFieldFirstName

	// UserFieldLastName TBD
	UserFieldLastName

	// UserFieldEmail TBD
	UserFieldEmail

	// UserFieldEmailVerified TBD
	UserFieldEmailVerified

	// UserFieldEncryptedPassword TBD
	UserFieldEncryptedPassword

	// UserFieldAvatarMediaID TBD
	UserFieldAvatarMediaID

	// UserFieldDescription TBD
	UserFieldDescription

	// UserFieldSystemUser TBD
	UserFieldSystemUser

	// UserFieldLocale TBD
	UserFieldLocale

	// UserFieldIsAnonymous TBD
	UserFieldIsAnonymous

	// UserFieldLastEventSeqNo TBD
	UserFieldLastEventSeqNo

	// UserFieldNUnreadMessages TBD
	UserFieldNUnreadMessages

	// UserFieldNUnreadNotifications TBD
	UserFieldNUnreadNotifications

	// UserFieldTags TBD
	UserFieldTags

	// UserFieldSpeciality TBD
	UserFieldSpeciality
)

// UserFieldsList TBD
type UserFieldsList []UserField

// UserAllFields TBD
var UserAllFields = UserFieldsList{
	UserFieldID,
	UserFieldFirstName,
	UserFieldLastName,
	UserFieldEmail,
	UserFieldEmailVerified,
	UserFieldEncryptedPassword,
	UserFieldAvatarMediaID,
	UserFieldDescription,
	UserFieldSystemUser,
	UserFieldLocale,
	UserFieldIsAnonymous,
	UserFieldLastEventSeqNo,
	UserFieldNUnreadMessages,
	UserFieldNUnreadNotifications,
	UserFieldTags,
	UserFieldSpeciality,
}

// UserFieldsNames TBD
var UserFieldsNames = [...]string{
	"id",
	"first_name",
	"last_name",
	"email",
	"email_verified",
	"encrypted_password",
	"avatar_media_id",
	"description",
	"system_user",
	"locale",
	"is_anonymous",
	"last_event_seq_no",
	"n_unread_messages",
	"n_unread_notifications",
	"tags",
	"speciality",
}

// Name TBD
func (f UserField) Name() string {
	if int(f) > len(UserFieldsNames)-1 {
		return "unknown"
	}
	return UserFieldsNames[f]
}

// JoinedNames TBD
func (l UserFieldsList) JoinedNames() string {
	return l.JoinedNamesWithAlias("")
}

// JoinedNamesWithAlias TBD
func (l UserFieldsList) JoinedNamesWithAlias(alias string) string {
	var aliasPrefix string
	if alias != "" {
		aliasPrefix = alias + "."
	}

	var buf bytes.Buffer
	for idx, f := range l {
		if idx != 0 {
			buf.WriteString(",")
		}
		buf.WriteString(aliasPrefix)
		buf.WriteString("\"")
		buf.WriteString(f.Name())
		buf.WriteString("\"")
	}
	return buf.String()
}

// Placeholders TBD
func (l UserFieldsList) Placeholders() string {
	var buf bytes.Buffer
	for idx := range l {
		if idx != 0 {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprint("$", idx+1))
	}
	return buf.String()
}

// Del TBD
func (l UserFieldsList) Del(fields ...UserField) UserFieldsList {
	var res = make(UserFieldsList, 0, len(l))
	for _, srcFld := range l {
		remove := false
		for _, delFld := range fields {
			if srcFld == delFld {
				remove = true
				break
			}
		}
		if !remove {
			res = append(res, srcFld)
		}
	}
	return res
}

// PushBack TBD
func (l UserFieldsList) PushBack(fields ...UserField) UserFieldsList {
	var res = make(UserFieldsList, 0, len(l)+len(fields))
	for _, f := range l {
		res = append(res, f)
	}
	for _, f := range fields {
		res = append(res, f)
	}
	return res
}

// PushFront TBD
func (l UserFieldsList) PushFront(fields ...UserField) UserFieldsList {
	var res = make(UserFieldsList, 0, len(l)+len(fields))
	for _, f := range fields {
		res = append(res, f)
	}
	for _, f := range l {
		res = append(res, f)
	}
	return res
}

// FieldsValues TBD
func (x *User) FieldsValues(fields UserFieldsList) []interface{} {
	values := make([]interface{}, 0, len(fields))
	for _, f := range fields {
		values = append(values, x.FieldValue(f))
	}
	return values
}

// FieldValue TBD
func (x *User) FieldValue(f UserField) interface{} {
	switch f {
	case UserFieldID:
		return x.ID
	case UserFieldFirstName:
		return x.FirstName
	case UserFieldLastName:
		return x.LastName
	case UserFieldEmail:
		return x.Email
	case UserFieldEmailVerified:
		return x.EmailVerified
	case UserFieldEncryptedPassword:
		return x.EncryptedPassword
	case UserFieldAvatarMediaID:
		return &x.AvatarMediaID
	case UserFieldDescription:
		return x.Description
	case UserFieldSystemUser:
		return x.SystemUser
	case UserFieldLocale:
		return x.Locale
	case UserFieldIsAnonymous:
		return x.IsAnonymous
	case UserFieldLastEventSeqNo:
		return x.LastEventSeqNo
	case UserFieldNUnreadMessages:
		return x.NUnreadMessages
	case UserFieldNUnreadNotifications:
		return x.NUnreadNotifications
	case UserFieldTags:
		return x.Tags
	case UserFieldSpeciality:
		return &x.Speciality
	}
	return nil
}

// SetFieldValue TBD
func (x *User) SetFieldValue(f UserField, v interface{}) error {
	switch f {
	case UserFieldID:
		x.ID = v.(int64)
	case UserFieldFirstName:
		x.FirstName = v.(string)
	case UserFieldLastName:
		x.LastName = v.(string)
	case UserFieldEmail:
		x.Email = v.(string)
	case UserFieldEmailVerified:
		x.EmailVerified = v.(bool)
	case UserFieldEncryptedPassword:
		x.EncryptedPassword = v.(string)
	case UserFieldAvatarMediaID:
		if v == nil {
			x.AvatarMediaID = nil
		} else {
			value := v.(int64)
			x.AvatarMediaID = &value
		}
	case UserFieldDescription:
		x.Description = v.(string)
	case UserFieldSystemUser:
		x.SystemUser = v.(bool)
	case UserFieldLocale:
		x.Locale = v.(string)
	case UserFieldIsAnonymous:
		x.IsAnonymous = v.(bool)
	case UserFieldLastEventSeqNo:
		x.LastEventSeqNo = v.(int64)
	case UserFieldNUnreadMessages:
		x.NUnreadMessages = v.(int32)
	case UserFieldNUnreadNotifications:
		x.NUnreadNotifications = v.(int32)
	case UserFieldTags:
		if v == nil {
			x.Tags = nil
		} else if t, ok := v.(pgtype.Value); ok {
			if err := t.AssignTo(&x.Tags); err != nil {
				return err
			}
		} else {
			x.Tags = v.([]string)
		}
	case UserFieldSpeciality:
		if v == nil {
			x.Speciality = nil
		} else {
			value := v.(string)
			x.Speciality = &value
		}
	}
	return nil
}

// UserQuerier TBD
type UserQuerier interface {
	Query(sql string, args ...interface{}) (*pgx.Rows, error)
	QueryRow(sql string, args ...interface{}) *pgx.Row
	Exec(sql string, arguments ...interface{}) (commandTag pgx.CommandTag, err error)
}

// UserRows TBD
type UserRows struct {
	rows   *pgx.Rows
	fields UserFieldsList
}

// Close TBD
func (r *UserRows) Close() {
	if r.rows == nil {
		return
	}
	r.rows.Close()
}

// Next TBD
func (r *UserRows) Next() bool {
	if r.rows == nil {
		return false
	}

	return r.rows.Next()
}

// Err TBD
func (r *UserRows) Err() error {
	if r.rows == nil {
		return errors.New("empty rows")
	}
	return r.rows.Err()
}

// ScanTo TBD
func (r *UserRows) ScanTo(x *User) error {
	values, err := r.rows.Values()
	if err != nil {
		return err
	}
	for idx, v := range values {
		if err := x.SetFieldValue(r.fields[idx], v); err != nil {
			return err
		}
	}

	return nil
}

// Scan TBD
func (r *UserRows) Scan() (x *User, err error) {
	x = new(User)
	err = r.ScanTo(x)
	return
}

// ScanAll TBD
func (r *UserRows) ScanAll(sizeHint int) ([]*User, error) {
	defer r.Close()

	if sizeHint == 0 {
		sizeHint = 10
	}

	var list = make([]*User, 0, sizeHint)

	for r.Next() {
		item, err := r.Scan()
		if err != nil {
			return list, err
		}
		list = append(list, item)
	}

	return list, r.Err()
}

// UserRow TBD
type UserRow UserRows

// ScanTo TBD
func (r *UserRow) ScanTo(x *User) error {
	rows := (*UserRows)(r)
	defer rows.Close()

	if rows.Err() != nil {
		return rows.Err()
	}

	if !rows.Next() {
		if rows.Err() == nil {
			return pgx.ErrNoRows
		}
		return rows.Err()
	}

	return rows.ScanTo(x)
}

// Scan TBD
func (r *UserRow) Scan() (x *User, err error) {
	x = new(User)
	err = r.ScanTo(x)
	return
}

// QueryUser TBD
func QueryUser(q UserQuerier, fields UserFieldsList, sql string, args ...interface{}) (*UserRows, error) {
	pgxRows, err := q.Query(sql, args...)
	if err != nil {
		return nil, err
	}

	return &UserRows{rows: pgxRows, fields: fields}, nil
}

// QueryUserRow TBD
func QueryUserRow(q UserQuerier, fields UserFieldsList, sql string, args ...interface{}) *UserRow {
	pgxRows, _ := q.Query(sql, args...)
	return &UserRow{rows: pgxRows, fields: fields}
}

// ScanUserList TBD
func ScanUserList(q UserQuerier, fields UserFieldsList, sql string, args ...interface{}) ([]*User, error) {
	rows, err := QueryUser(q, fields, sql, args...)
	if err != nil {
		return nil, err
	}
	return rows.ScanAll(0)
}

// ScanUser TBD
func ScanUser(q UserQuerier, fields UserFieldsList, sql string, args ...interface{}) (*User, error) {
	x, err := QueryUserRow(q, fields, sql, args...).Scan()
	if err == pgx.ErrNoRows {
		return nil, nil
	}
	return x, err
}
