// !! Autogenerated file, do not edit!
package dto

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/mitchellh/mapstructure"
	"time"

	"github.com/jackc/pgx"
)

// EventField TBD
type EventField int

const (
	// EventFieldID TBD
	EventFieldID EventField = iota

	// EventFieldUserID TBD
	EventFieldUserID

	// EventFieldSeqNo TBD
	EventFieldSeqNo

	// EventFieldType TBD
	EventFieldType

	// EventFieldStatus TBD
	EventFieldStatus

	// EventFieldCreationTime TBD
	EventFieldCreationTime

	// EventFieldEventUnion TBD
	EventFieldEventUnion
)

// EventFieldsList TBD
type EventFieldsList []EventField

// EventAllFields TBD
var EventAllFields = EventFieldsList{
	EventFieldID,
	EventFieldUserID,
	EventFieldSeqNo,
	EventFieldType,
	EventFieldStatus,
	EventFieldCreationTime,
	EventFieldEventUnion,
}

// EventFieldsNames TBD
var EventFieldsNames = [...]string{
	"id",
	"user_id",
	"seq_no",
	"type",
	"status",
	"creation_time",
	"extra",
}

// Name TBD
func (f EventField) Name() string {
	if int(f) > len(EventFieldsNames)-1 {
		return "unknown"
	}
	return EventFieldsNames[f]
}

// JoinedNames TBD
func (l EventFieldsList) JoinedNames() string {
	return l.JoinedNamesWithAlias("")
}

// JoinedNamesWithAlias TBD
func (l EventFieldsList) JoinedNamesWithAlias(alias string) string {
	var aliasPrefix string
	if alias != "" {
		aliasPrefix = alias + "."
	}

	var buf bytes.Buffer
	for idx, f := range l {
		if idx != 0 {
			buf.WriteString(",")
		}
		buf.WriteString(aliasPrefix)
		buf.WriteString("\"")
		buf.WriteString(f.Name())
		buf.WriteString("\"")
	}
	return buf.String()
}

// Placeholders TBD
func (l EventFieldsList) Placeholders() string {
	var buf bytes.Buffer
	for idx := range l {
		if idx != 0 {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprint("$", idx+1))
	}
	return buf.String()
}

// Del TBD
func (l EventFieldsList) Del(fields ...EventField) EventFieldsList {
	var res = make(EventFieldsList, 0, len(l))
	for _, srcFld := range l {
		remove := false
		for _, delFld := range fields {
			if srcFld == delFld {
				remove = true
				break
			}
		}
		if !remove {
			res = append(res, srcFld)
		}
	}
	return res
}

// PushBack TBD
func (l EventFieldsList) PushBack(fields ...EventField) EventFieldsList {
	var res = make(EventFieldsList, 0, len(l)+len(fields))
	for _, f := range l {
		res = append(res, f)
	}
	for _, f := range fields {
		res = append(res, f)
	}
	return res
}

// PushFront TBD
func (l EventFieldsList) PushFront(fields ...EventField) EventFieldsList {
	var res = make(EventFieldsList, 0, len(l)+len(fields))
	for _, f := range fields {
		res = append(res, f)
	}
	for _, f := range l {
		res = append(res, f)
	}
	return res
}

// FieldsValues TBD
func (x *Event) FieldsValues(fields EventFieldsList) []interface{} {
	values := make([]interface{}, 0, len(fields))
	for _, f := range fields {
		values = append(values, x.FieldValue(f))
	}
	return values
}

// FieldValue TBD
func (x *Event) FieldValue(f EventField) interface{} {
	switch f {
	case EventFieldID:
		return x.ID
	case EventFieldUserID:
		return x.UserID
	case EventFieldSeqNo:
		return x.SeqNo
	case EventFieldType:
		return int16(x.Type)
	case EventFieldStatus:
		return int16(x.Status)
	case EventFieldCreationTime:
		return x.CreationTime
	case EventFieldEventUnion:
		data, _ := json.Marshal(x.EventUnion)
		return string(data)
	}
	return nil
}

// SetFieldValue TBD
func (x *Event) SetFieldValue(f EventField, v interface{}) error {
	switch f {
	case EventFieldID:
		x.ID = v.(int64)
	case EventFieldUserID:
		x.UserID = v.(int64)
	case EventFieldSeqNo:
		x.SeqNo = v.(int64)
	case EventFieldType:
		x.Type = EventType(v.(int16))
	case EventFieldStatus:
		x.Status = EventStatus(v.(int16))
	case EventFieldCreationTime:
		x.CreationTime = v.(time.Time)
	case EventFieldEventUnion:
		if v != nil {
			decoder, err := mapstructure.NewDecoder(&mapstructure.DecoderConfig{
				TagName: "json",
				Result:  &x.EventUnion,
			})
			if err != nil {
				return err
			}
			err = decoder.Decode(v)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// EventQuerier TBD
type EventQuerier interface {
	Query(sql string, args ...interface{}) (*pgx.Rows, error)
	QueryRow(sql string, args ...interface{}) *pgx.Row
	Exec(sql string, arguments ...interface{}) (commandTag pgx.CommandTag, err error)
}

// EventRows TBD
type EventRows struct {
	rows   *pgx.Rows
	fields EventFieldsList
}

// Close TBD
func (r *EventRows) Close() {
	if r.rows == nil {
		return
	}
	r.rows.Close()
}

// Next TBD
func (r *EventRows) Next() bool {
	if r.rows == nil {
		return false
	}

	return r.rows.Next()
}

// Err TBD
func (r *EventRows) Err() error {
	if r.rows == nil {
		return errors.New("empty rows")
	}
	return r.rows.Err()
}

// ScanTo TBD
func (r *EventRows) ScanTo(x *Event) error {
	values, err := r.rows.Values()
	if err != nil {
		return err
	}
	for idx, v := range values {
		if err := x.SetFieldValue(r.fields[idx], v); err != nil {
			return err
		}
	}

	return nil
}

// Scan TBD
func (r *EventRows) Scan() (x *Event, err error) {
	x = new(Event)
	err = r.ScanTo(x)
	return
}

// ScanAll TBD
func (r *EventRows) ScanAll(sizeHint int) ([]*Event, error) {
	defer r.Close()

	if sizeHint == 0 {
		sizeHint = 10
	}

	var list = make([]*Event, 0, sizeHint)

	for r.Next() {
		item, err := r.Scan()
		if err != nil {
			return list, err
		}
		list = append(list, item)
	}

	return list, r.Err()
}

// EventRow TBD
type EventRow EventRows

// ScanTo TBD
func (r *EventRow) ScanTo(x *Event) error {
	rows := (*EventRows)(r)
	defer rows.Close()

	if rows.Err() != nil {
		return rows.Err()
	}

	if !rows.Next() {
		if rows.Err() == nil {
			return pgx.ErrNoRows
		}
		return rows.Err()
	}

	return rows.ScanTo(x)
}

// Scan TBD
func (r *EventRow) Scan() (x *Event, err error) {
	x = new(Event)
	err = r.ScanTo(x)
	return
}

// QueryEvent TBD
func QueryEvent(q EventQuerier, fields EventFieldsList, sql string, args ...interface{}) (*EventRows, error) {
	pgxRows, err := q.Query(sql, args...)
	if err != nil {
		return nil, err
	}

	return &EventRows{rows: pgxRows, fields: fields}, nil
}

// QueryEventRow TBD
func QueryEventRow(q EventQuerier, fields EventFieldsList, sql string, args ...interface{}) *EventRow {
	pgxRows, _ := q.Query(sql, args...)
	return &EventRow{rows: pgxRows, fields: fields}
}

// ScanEventList TBD
func ScanEventList(q EventQuerier, fields EventFieldsList, sql string, args ...interface{}) ([]*Event, error) {
	rows, err := QueryEvent(q, fields, sql, args...)
	if err != nil {
		return nil, err
	}
	return rows.ScanAll(0)
}

// ScanEvent TBD
func ScanEvent(q EventQuerier, fields EventFieldsList, sql string, args ...interface{}) (*Event, error) {
	x, err := QueryEventRow(q, fields, sql, args...).Scan()
	if err == pgx.ErrNoRows {
		return nil, nil
	}
	return x, err
}
